using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;

namespace Microsoft.Web.Samples
{

    /// <summary>
    /// Automates the creation of sprites and base64 inlining for CSS
    /// </summary>
    public class ImageOptimizations
    {
        private const string SettingsFileName = "settings.xml";
        private const string CssFileName = "sprite.less";
        private const string GeneratedSpriteFileName = "sprite{0}";
        private const string SpriteFileNameRegex = "^sprite[0-9]+$";

        private readonly string[] _extensions = { "*.jpg", "*.gif", "*.png", "*.bmp", "*.jpeg" };
        private readonly object _lockObj = new object();
        private const string Indent = "    ";
        private const string IndentHover = "        ";

        /// <summary>
        /// Executes the image optimizer on a specific subdirectory of the root image directory (non-recursive)
        /// </summary>
        /// <param name="path">The path to the directory to be rebuilt</param>
        /// <returns>False if the directory does not exist</returns>
        public bool ProcessDirectory(string path)
        {
            // Check if directory was deleted
            if (!Directory.Exists(path))
            {
                return false;
            }

            try
            {

                // Make a list of the disk locations of each image
                var imageLocations = new List<string>();

                foreach (string extension in _extensions)
                {
                    imageLocations.AddRange(Directory.GetFiles(path, extension));
                }

                // Make sure to delete any existing sprites (or other images with the filename sprite###.imageExtension)
                imageLocations.RemoveAll(DeleteSpriteFile);

                // Import settings from settings file
                var settings = GetSettings(path);

                // Create pointer to the CSS output file
                lock (_lockObj)
                {
                    using (var cssLowCompatOutput = new StreamWriter(Path.Combine(path, CssFileName), append: false))
                    {
                        PerformOptimizations(path, settings, cssLowCompatOutput, imageLocations);
                    }
                }

                imageLocations.Clear();
                foreach (string extension in _extensions)
                {
                    imageLocations.AddRange(Directory.GetFiles(path, extension));
                }

                return true;
            }
            catch (Exception)
            {
                if (!Directory.Exists(path))
                {
                    return false;
                }
                throw;
            }
        }

        /// <summary>
        /// Checks if an image (passed by path or image name) is a sprite image or CSS file created by the framework
        /// </summary>
        /// <param name="path">The path or filename of the image in question</param>
        /// <returns>True if the image is a sprite, false if it is not</returns>
        private bool IsOutputSprite(string path)
        {
            var name = Path.GetFileNameWithoutExtension(path);
            var extension = Path.GetExtension(path).TrimStart('.');
            var imageExtensions = new List<string>(_extensions);

            return ((Regex.Match(name, SpriteFileNameRegex).Success && imageExtensions.Contains("*." + extension)) || extension == "css");
        }

        internal string MakeCssSelector(string pathToImage)
        {
            string cssFilename = TrimPathForCss(pathToImage);
            return CssNameHelper.GenerateSelector(cssFilename);
        }

        private string TrimPathForCss(string pathToImage)
        {
            pathToImage = MakePathRelative(pathToImage);
            return pathToImage.Replace('\\', '/');
        }

        /// <summary>
        /// Checks if the image at the path is a sprite generated by the framework, and deletes it if it was
        /// </summary>
        /// <param name="path">The file path to the image in question</param>
        /// <returns>True if the image was a sprite (and was by extension, deleted)</returns>
        private bool DeleteSpriteFile(string path)
        {
            if (IsOutputSprite(path))
            {
                File.Delete(path);
                return true;
            }

            return false;
        }

        private void PerformOptimizations(string path, ImageSettings settings, TextWriter cssLowCompatOutput, List<string> imageLocations)
        {
            var spriteInfo = new SpriteInfoBuilder().Build(settings, imageLocations);
            if (spriteInfo.Images.Count > 0)
            {
                GenerateSprite(path, settings, spriteInfo, cssLowCompatOutput);
            }
        }

        private string MakePathRelative(string fullPath)
        {
            var fileInfo = new FileInfo(fullPath);
            return fileInfo.Directory.Name + "-" + fileInfo.Name.Replace(fileInfo.Extension, "");
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private void GenerateSprite(string path, ImageSettings settings, SpriteInfo spriteInfo, TextWriter cssLowCompatOutput)
        {
            using (Bitmap sprite = new Bitmap(spriteInfo.Width, spriteInfo.Height))
            {
                using (Graphics drawingSurface = Graphics.FromImage(sprite))
                {
                    // Set the background to the specs from the settings file
                    drawingSurface.Clear(settings.BackgroundColor);

                    // Make the final sprite and save it
                    foreach (var image in spriteInfo.Images)
                    {
                        drawingSurface.DrawImage(image.Bitmap, new Rectangle(image.Position.XOffset, image.Position.YOffset, image.Bitmap.Width, image.Bitmap.Height));
                        // Add the CSS data
                        GenerateCss(image, settings.Format, cssLowCompatOutput);

                        var hoverImage = image.HoverImage;
                        if (hoverImage != null)
                        {
                            drawingSurface.DrawImage(hoverImage.Bitmap, new Rectangle(hoverImage.Position.XOffset, hoverImage.Position.YOffset, hoverImage.Bitmap.Width, hoverImage.Bitmap.Height));
                        }

                    }

                    // Set the encoder parameters and make the image
                    try
                    {
                        using (EncoderParameters spriteEncoderParameters = new EncoderParameters(1))
                        {
                            spriteEncoderParameters.Param[0] = new EncoderParameter(Encoder.Quality, settings.Quality);

                            // Attempt to save the image to disk with the specified encoder
                            sprite.Save(Path.Combine(path, GenerateSpriteFileName(settings.Format)), GetEncoderInfo(settings.Format), spriteEncoderParameters);
                        }
                    }
                    catch (Exception)
                    {
                        // If errors occur, get the CLI to auto-choose an encoder. Unfortunately this means that the quality settings will be not used.
                        try
                        {
                            sprite.Save(Path.Combine(path, GenerateSpriteFileName(settings.Format)));
                        }
                        catch (Exception)
                        {
                            // If errors occur again, try to save as a png
                            sprite.Save(Path.Combine(path, GenerateSpriteFileName("png")));
                        }
                    }
                }
            }
        }

        private string GenerateSpriteFileName(string fileExtension)
        {
            return String.Format(CultureInfo.InvariantCulture, GeneratedSpriteFileName, DateTime.Today.ToString("yyyyMMdd")) + "." + fileExtension;
        }

        private void GenerateCss(ImageInfo imageInfo, string fileExtension, TextWriter cssOutput)
        {
            var funcParams = string.Format("(@backgroundRepeat: no-repeat, @width: {0}px, @height: {1}px)",
                imageInfo.Bitmap.Width.ToString(CultureInfo.InvariantCulture),
                imageInfo.Bitmap.Height.ToString(CultureInfo.InvariantCulture));


            cssOutput.WriteLine("." + MakeCssSelector(imageInfo.FileName) + funcParams);
            cssOutput.WriteLine("{");
            cssOutput.WriteLine(Indent + "width: @width;");
            cssOutput.WriteLine(Indent + "height: @height;");
            GenerateCssBackgroundLow(Indent, cssOutput, fileExtension, imageInfo.Position.XOffset, imageInfo.Position.YOffset);
            cssOutput.WriteLine(Indent + "background-repeat: @backgroundRepeat;");


            var hoverImage = imageInfo.HoverImage;
            if (hoverImage != null)
            {
                cssOutput.WriteLine(Indent + "&:hover");
                cssOutput.WriteLine(Indent + "{");
                cssOutput.WriteLine(IndentHover + "width: @width;");
                cssOutput.WriteLine(IndentHover + "height: @height;");
                GenerateCssBackgroundLow(IndentHover, cssOutput, fileExtension, hoverImage.Position.XOffset, hoverImage.Position.YOffset);
                cssOutput.WriteLine(IndentHover + "background-repeat: @backgroundRepeat;");
                cssOutput.WriteLine(Indent + "}");
            }

            cssOutput.WriteLine("}");
        }

        private string GetOffsetPosition(int offset)
        {
            // Offset of 0 doesn't need to have the minus sign
            if (offset == 0)
            {
                return offset.ToString(CultureInfo.InvariantCulture);
            }
            return "-" + offset.ToString(CultureInfo.InvariantCulture);
        }

        private void GenerateCssBackgroundLow(string identation, TextWriter cssOutput, string fileExtension, int xOffset, int yOffset)
        {
            string xPosition = GetOffsetPosition(xOffset);
            string yPosition = GetOffsetPosition(yOffset);

            cssOutput.WriteLine(identation + "background-image: url(" + GenerateSpriteFileName(fileExtension) + ");");
            cssOutput.WriteLine(identation + "background-position: " + xPosition + "px " + yPosition + "px;");
        }


        private ImageSettings GetSettings(string path)
        {
            var settings = new ImageSettings();
            string settingFileLocation = Path.Combine(path, SettingsFileName);
            if (!File.Exists(settingFileLocation))
            {
                return settings;
            }

            XmlTextReader settingsData;
            // Open the settings file. If it fails here, we throw an exception since we expect the file to be there and readable.
            using (settingsData = new XmlTextReader(settingFileLocation))
            {
                while (settingsData.Read())
                {
                    if (settingsData.NodeType == XmlNodeType.Element)
                    {
                        string nodeName = settingsData.Name;

                        if (nodeName.Equals("FileFormat", StringComparison.OrdinalIgnoreCase))
                        {
                            settings.Format = settingsData.ReadElementContentAsString().Trim('.');
                        }
                        else if (nodeName.Equals("Quality", StringComparison.OrdinalIgnoreCase))
                        {
                            settings.Quality = settingsData.ReadElementContentAsInt();
                        }
                        else if (nodeName.Equals("MaxSize", StringComparison.OrdinalIgnoreCase))
                        {
                            settings.MaxSize = settingsData.ReadElementContentAsInt();
                        }
                        else if (nodeName.Equals("BackgroundColor", StringComparison.OrdinalIgnoreCase))
                        {
                            string output = settingsData.ReadElementContentAsString();
                            int temp = Int32.Parse(output, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                            settings.BackgroundColor = Color.FromArgb(temp);
                        }
                        else if (nodeName.Equals("Base64Encoding", StringComparison.OrdinalIgnoreCase))
                        {
                            settings.Base64 = settingsData.ReadElementContentAsBoolean();
                        }
                        else if (nodeName.Equals("TileInXAxis", StringComparison.OrdinalIgnoreCase))
                        {
                            settings.TileInXAxis = settingsData.ReadElementContentAsBoolean();
                        }
                    }
                }
            }

            return settings;
        }

        // ReSharper disable UnusedMember.Local
        private string GetTrimmedPath(string path)
        // ReSharper restore UnusedMember.Local
        {
            return path
                .TrimEnd(Path.AltDirectorySeparatorChar)
                .TrimEnd(Path.DirectorySeparatorChar);
        }

        private ImageCodecInfo GetEncoderInfo(string format)
        {
            format = format.ToUpperInvariant();

            // Find the appropriate codec for the specified file extension
            if (format == "JPG")
            {
                format = "JPEG";
            }

            format = "IMAGE/" + format;
            // Get a list of all the available encoders
            ImageCodecInfo[] encoders = ImageCodecInfo.GetImageEncoders();

            // Search the list for the proper encoder
            foreach (ImageCodecInfo encoder in encoders)
            {
                if (encoder.MimeType.ToUpperInvariant() == format)
                {
                    return encoder;
                }
            }

            // If a format cannot be found, throw an exception
            throw new FormatException("Encoder not found! The CLI will attempt to automatically choose an encoder, however image quality settings will be ignored");
        }
    }
}